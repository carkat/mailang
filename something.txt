- a comment
num   â† 5
float â† 5.5
A     â† 1 2 3
B     â† 2 3 4
D     â† a`A b`num c`6

emptyArr â† []

- also empty obj
emptyDict â† {}

multiLineArr â† 
    1 2 3
    4 5 6

nestedArr â†
    1 2 3 ; 1 2 3

multiDimArr â†
   (1 2 3) (1 2 3); (1 2 3) (1 2 ( 1 2 3))

multiLinDict â†
    a`A
    b`num
    c`6
    nestedDict`
      a`A
      b`num
      c`6

- iff also works as a function continuation 
truthTable â†
    true   ` T
    false  ` F
    isTrue `Â¬F
    isFalse`Â¬T
    and    ` T & T
    or     ` T â‹ T
    iff    ` T & T âŸ· T
    xor    ` F & T â¨ T

- functionName arg1 arg2 = body
add a b = a + b
sub a b = a - b
sum a b = Î£ a b 
sums A  = Î£ A

- anonymous function syntax
- name â† arg1 arg2...: body
fn â† a b: a + b


- the first | is read "if'
- the second | is read "else if'
conditionalFunction a b = 
    | true  â†’ true
    | true  
    & true  â†’ true
    | false   
    â‹ true  â†’ true
    | (
        longTrueVariable 
        & reallyLongTrueVariableName
      ) â† true
    | default
    : true    â† T
      false   â† F
      default â† F
      longTrueVariable â† true
      reallyLongTrueVariableName â† true


- collection operations
union        A B = A â‹ƒ B
disjoint     A B = A â‹‚ B
includes     A B = A âŠ‚ B
includesOrEq A B = A âŠ† B
equalSet     A B = A = B

concat A B = A + B
remove A B = A - B


- if you need persistent variables in function scope
- : is read "where"
sums2 A = Î£ B
    : B â† filter (n: (n % 2) = 0) A

sums3 A = Î£ B
    : B â† filter (n i C: n < C(i + 1)) A




- âˆˆ is the iteration operator
- by default âˆˆ produces a few arguments
- (tuple of values) index âˆˆ Array
- { (the value to return) | interation, bool, bool, bool...}
- not wrapped in {} returns a single value
- identity set builder
setBuilder A = { a | a âˆˆ A }

- execution of a function on the right returns a if fn a
filter   fn  A = { a | a âˆˆ A , fn a }

- execution of a function on the left of | returns a mapped value
map fn  A = { fn a | a âˆˆ A }

- forall asserts that every value in A consides with some truth statement
- returns T or F
- written much like for x in A: x != 0
every fn A = âˆ€ a âˆˆ A, fn a

- âˆƒ is an array operator that when applied asserts a single value must be matched
- and that it a single value will be returned, stopping execution of the loop
includes val A = a | âˆƒ a âˆˆ A, a = val

- ğš¤ is the index of an array when âˆˆ is used
indexOf  val A =   ğš¤ | âˆƒ a ğš¤ âˆˆ A , a = val
indexOfs fn  A = { ğš¤ |   a ğš¤ âˆˆ A , a = val }
locate   fn  A =   ğš¤ | âˆƒ a ğš¤ âˆˆ A , fn a
loci     fn  A = { ğš¤ |   a ğš¤ âˆˆ A , fn a }

reduce   fn  A = Î£ A fn
uniqueSet    A = { B + a | a âˆˆ A, Â¬exists a B }
    : B â† []


solution x y = map (mapped Îº) x
  : Îº â† #x Ï y
    Î± â† 'abcdefghijklmnopqrstuvwxyz
    fn Îº char ğš¤ = Î±[(k[ğš¤] Î¹Î± + char Î¹Î± % #Î±) % #Î±] 

f a b c â† 
  | a < b      â†’ a + b + c 
  | a > b < c  â†’ a + b - c 
  | a < b
  & a = 2b > b + c â†’ 3a + 2b

        