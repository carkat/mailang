- a comment
num   ⟵ 5
float ⟵ 5.5
A     ⟵ 1 2 3
B     ⟵ 2 3 4
D     ⟵ a`A b`num c`6

emptyArr ⟵ []

- also empty obj
emptyDict ⟵ {}

multiLineArr ⟵ 
    1 2 3
    4 5 6

nestedArr ⟵
    1 2 3 ; 1 2 3

multiDimArr ⟵
   (1 2 3) (1 2 3); (1 2 3) (1 2 ( 1 2 3))

multiLinDict ⟵
    a`A
    b`num
    c`6
    nestedDict`
      a`A
      b`num
      c`6

- iff also works as a function continuation 
truthTable ⟵
    true   ` T
    false  ` F
    isTrue `¬F
    isFalse`¬T
    and    ` T & T
    or     ` T ⋁ T
    iff    ` T & T ⟷ T
    xor    ` F & T ⨁ T

- functionName arg1 arg2 = body
add a b = a + b
sub a b = a - b
sum a b = Σ a b 
sums A  = Σ A

- anonymous function syntax
- name ⟵ arg1 arg2...: body
fn ⟵ a b: a + b


- the first | is read "if'
- the second | is read "else if'
conditionalFunction a b = 
    | true  ⟵ true
    | true  
    & true  ⟵ true
    | false   
    ⋁ true  ⟵ true
    | (
        longTrueVariable 
        & reallyLongTrueVariableName
      ) ⟵ true
    | default
    : true    ⟵ T
      false   ⟵ F
      default ⟵ F
      longTrueVariable ⟵ true
      reallyLongTrueVariableName ⟵ true


- collection operations
union        A B = A ⋃ B
disjoint     A B = A ⋂ B
includes     A B = A ⊂ B
includesOrEq A B = A ⊆ B
equalSet     A B = A = B

concat A B = A + B
remove A B = A - B


- if you need persistent variables in function scope
- : is read "where"
sums2 A = Σ B
    : B ⟵ filter (n: (n % 2) = 0) A

sums3 A = Σ B
    : B ⟵ filter (n i C: n < C(i + 1)) A



- ∈ is the iteration operator
- by default ∈ produces a few arguments
- (tuple of values) index ∈ Array
- { (the value to return) | iteration, bool, bool, bool...}
setBuilder               A = { a | a ∈ A }
setBuilderWithIterators  A = { a + b + c | (a b c) a i ∈ A }

filter   fn A = { a | a i ∈ A, fn a i A}
map      fn A = { fn a | a ∈ A }


- TODO: figure out how to do reduction to a single val
- does for all work?
reduce fn A = result
    : result = ∀ (a b) ∈ A | fn a b

- T or F
exists      val A = ∃ a ∈ A | a = val
eachTrue boolFn A = ∀ a ∈ A | boolFn a

uniqueSet   A = { a | a ∈ A, ¬exists a B }
    : B ⟵ []


fn a b = add a b ⟶ sub a ⟶ add _ a ⟶ someFn b




getOlder p = person ..p (p.age + 1)

person name isAwesome age = 
  name     ` name
  isAwesome` isAwesome
  age      ` age
  getOlder ` getOlder self

Kyle      ⟵ person 'Zucker' T 1000
olderKyle ⟵ Kyle.isAwesome ⟷ Kyle.getOlder
  

composeKey key keyword secret = 
  | space ≥ #key ⟶ composeKey (key +             keyWord)  keyWord secret
  | space ≠ 0    ⟶ composeKey (key + (take space keyWord)) keyWord secret
  | key
  : space ⟵ #passPhrase - #key

- #aaaaaaaaaaaaa = 13
aaaaaaaaaaaaa ⟵ composeKey '' 'aaaa' 'thisisastring'


find val arr = { i | a i ∈ A, a = val }

a ⟵ 'abcdefghijklmnopqrstuvwxyz'
solution s p = ((k c i: (f k[i] ⌀ a)[f c]) (#s ρ p)) / s 
  : f c = find c a














#secret ρ 'aaaa'
∇
↑
↓

\log