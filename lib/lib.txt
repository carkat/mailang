- a comment
num   ← 5
float ← 5.5
A     ← 1 2 3
B     ← 2 3 4
D     ← a`A b`num c`6


emptyArr ← []

- also empty obj
emptyDict ← {}

multiLineArr ← 
  1 2 3 
  4 5 6 
  

nestedArr ←
  1 2 3 ; 1 2 3

multiDimArr ←
  (1 2 3) (1 2 3); (1 2 3) (1 2 (1 2 3))
   
multiLinDict ←
  a`A
  b`num
  c`6
  nestedDict`
    a`A
    b`num
    c`6

- iff also works as a function continuation 
truthTable ←
  true   ` T
  false  ` F
  isTrue `¬F
  isFalse`¬T
  and    ` T & T
  or     ` T ⋁ T
  iff    ` T & T ⟷ T
  xor    ` F & T ⨁ T

- functionName arg1 arg2 = body
add a b = a + b
sub a b = a - b
sum a b = Σ a b 
sums A  = Σ A

- anonymous function syntax
- name ← arg1 arg2...: body
f ← a b: a + b


- the first | is read "if'
- the second | is read "else if'
conditionalFunction a b = 
  | true  → true
  | true  
  & true  → true
  | false   
  ⋁ true  → true
  | (longTrueVariable 
    & reallyLongTrueVariableName) → true
  | default
: true    ← T
  false   ← F
  default ← F
  longTrueVariable ← true
  reallyLongTrueVariableName ← true



- collection operations
union        A B = A ⋃ B
disjoint     A B = A ⋂ B
includes     A B = A ⊂ B
includesOrEq A B = A ⊆ B
equalSet     A B = A = B

concat A B = A + B
remove A B = A - B


- if you need persistent variables in function scope
- : is read "where"
sums2 A = Σ B
: B ← filter (a b: (n % 2) = 0) A


sums3 A = Σ B
: B ← filter (n i C: n < C(i + 1)) A




- ∈ is the iteration operator
- by default ∈ produces a few arguments
- (tuple of values) index ∈ Array
- { (the value to return) | interation, bool, bool, bool...}
- not wrapped in {} returns a single value
- identity set builder
setBuilder A = { a | a ∈ A }

- execution of a function on the right returns a if f a
filter f  A = { a | a i ∈ A , f a i A}

- execution of a function on the left of | returns a mapped value
map f A = { f a i A | a i ∈ A }

- forall asserts that every value in A consides with some truth statement
- returns T or F
- written much like for x in A: x != 0
every f A = ∀ a ∈ A, f a

- ∃ is an array operator that when applied asserts a single value must be matched
- and that it a single value will be returned, stopping execution of the loop
includes val A = a | ∃ a ∈ A, a = val

- i,j,k is the index of an array when ∈ is used
- they can be named anything
indexOf  val A =   i | ∃ a i ∈ A , a = val
indexOfs f  A = { i |   a i ∈ A , a = val }
locate   f  A =   i | ∃ a i ∈ A , f a
loci     f  A = { i |   a i ∈ A , f a }

reduce   f  A = Σ A f
uniqueSet   A = { B + a | a ∈ A, ¬exists a B }
: B ← []


α ← 'abcdefghijklmnopqrstuvwxyz'
solution secret password = map (mapped getKey) x
  : getKey ← #secret ρ password 
    f κ char i = α[(κ[i] ια + char ια % #α) % #α] 

f a b c =
| a < b      → a + b + c 
| a > b < c  → a + b - c 
| a < b
& a > b + c  → 2ab ÷ 3

fact n = (n = 1 → n) ⊕ ..n(∇n - 1)






map     A f = A/f
filter  A f = A|f
roll    A   = A□
deal    A n = A□n
indexOf A x = A?x
findInd A f = A?f

first   A x = A@x
first   A f = A@f
findAll A f = A@@f
enlist  A B C = ..A B C (1 2) 3 4



- A ← 1 2 ; 3 4
- B ← 1 2 ; 3 4
concat A B C = ..A B C
- (1 2 ; 3 4) (1 2 ; 3 4)

laminate A B C = A..B C
- 1 2 1 2 ;  
- 3 4 3 4

union A A = A ⋃ A
- 1 2 ; 3 4

drop   A n = A↓n
take   A n = A↑n
rotate A n = A↻n

r A n=A↑(i-#A)+A↑i:i←(n+#A)%#A

rotate A n = A↑(i-#A)+A↑i
:i ← (n + #A) % #A

typeCheck A = A ≊ 'A'

slice  A t d = take A t → Drop _ d
slice2 A t d = (A↑t)↓d
sortedInd  A = ↑A
sort   A     = A[↑A]
string ← '
  a multi line string
  '
string2 ← 'a single line string

smallest A = { a | a ∈ A, a < 1↑A } -> #_ = 1 -> 1↑_ ⊕ ∇ 1↷_


parseBody body = { main where }
: wSplit ← s ↓body
  split  ← '\n' ↓body
  main   ← 1↑splitOnWhere
  symbol ← ':'
  where  ← 
    f firstCharIsSymbol        → 
    f (firstLineOfWhereBody _) → 
    (ln: indentlvl _↑ln)    /_ → JoinAndParse

  f fn = fn | split
  firstCharIsSymbol ln        = 1↑(trim ln) = s
  firstLineOfWhereBody b x i  = b & (i >= b)
  indentlvl w                 = (x: x≠' '& notSymbol(x))?w

parseBody body = { main where }
: indentlvl w  = findIndex w  (x: x≠' ' & notSymbol(x))
  symbol     ← ':'
  splitOnSym ← body↓ symbol 
  split      ← body↓ '\n'
  main       ← splitOnWhere↑1
  wBegins    ← split| (x  : trim x → _↑1 = symbol)
  wBody      ← split| (_ i: wBegins & i >= wBegins)
  where      ← wbody/ (ln : indentlvl wBody → ln↑_) → JoinAndParse


- e = 2 3; 5 6; 8 9
- 2 3
- 5 6
- 8 9 

- f = 3; 6
fn a b = 
| #a < 9 → 'if'
| #a < 8 → 'elseif'
| #a < 7 → 'elseif'
| #a < 6 → 'elseif'
| 'default'
: a ← ι10
  b ← a[(ι3)]
  c ← a - 3
  d ← 
    1 2 3;
    4 5 6;
    7 8 9
  e ← d - (0 1) 
  f ← d[_ (1 2)]

f ← a = 5



fizzBuzz n = ιn / (x: five x + three x ⊕ x)
: isDivisibleBy n s x = ¬(x % n) → s ⊕ x
  three ← isDivisibleBy 3 'Buzz'
  five  ← isDivisibleBy 5 'Fizz'


z x -> h -> g -> f

battleship M = isValid M
: sortedLocation r = ↑r|(x: x = 0)
  checColumn M = M/(r:[;sortedLocation r])
  permutations ← ((4 1) (3 2) (3 1 1) (2 1 1 1))



bs M =
: shipsRemainig ← ships|(s: found s)
  ships   ← 4 2ρ3 3ρ2 4ρ1
  found s ← 

grid i: ι(ships↑1)/(s:s+i)
count


- special case when the board has only subs left
- special case, check that all ships don't touch
- ugghhhhh!
battleships board ships = 
| #ships & boardHasShip board → ∇ board 1↓ships 
| ¬(#ships) 'valid'
| 'invalid'
: s ← 1↑(↓ships)
  canMakeGrid  i      = i + s < #board 
  matrix       ri col = board[ι(s + ri);ι(s + col)]↑s
  gridHasShip  ri col = g ∃ shipInRowOrCol col
  : g ← matrix ri col
    shipInRowCol  col gridRow gi = (shipInRow col gridRow ri gi) ∨ (shipInCol col gridRow ri gi)
    shipInRow     col gridRow gi = gridRow_add = s & shipsDontTouch 'row' ri gi col
    shipInCol     col gridRow gi = gridRow_add = s & shipsDontTouch 'col' ri gi col

  boardHasShip board offset = #board → (board ∃ gridWithShip ⊕ ∇ 1↓board (o + 1))
  : gridWithShip r i = canMakeGrid i & canMakeGrid o & gridHasShip r i
    o ← offset ⊕ 0

  - make a box around the ship. if the box reduces to size of ship, its valid
  shipsDontTouch type ri gi col = shipLocation_(a row: a + row_add) = s
  : bounds       ← (i - 1 < #board) (i < #board) (i + 1 < #board)
    shipLocation ← 
    | type = 'row' → 
    | type = 'col' → 


